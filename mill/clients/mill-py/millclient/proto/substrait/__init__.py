# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: substrait/algebra.proto, substrait/capabilities.proto, substrait/extended_expression.proto, substrait/function.proto, substrait/parameterized_types.proto, substrait/plan.proto, substrait/type.proto, substrait/type_expressions.proto
# plugin: python-betterproto
# This file has been @generated
import warnings
from dataclasses import dataclass
from typing import List

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf

from . import extensions


class TypeNullability(betterproto.Enum):
    NULLABILITY_UNSPECIFIED = 0
    NULLABILITY_NULLABLE = 1
    NULLABILITY_REQUIRED = 2


class AggregationPhase(betterproto.Enum):
    """
    Describes which part of an aggregation or window function to perform within
     the context of distributed algorithms.
    """

    UNSPECIFIED = 0
    """Implies `INTERMEDIATE_TO_RESULT`."""

    INITIAL_TO_INTERMEDIATE = 1
    """
    Specifies that the function should be run only up to the point of
     generating an intermediate value, to be further aggregated later using
     INTERMEDIATE_TO_INTERMEDIATE or INTERMEDIATE_TO_RESULT.
    """

    INTERMEDIATE_TO_INTERMEDIATE = 2
    """
    Specifies that the inputs of the aggregate or window function are the
     intermediate values of the function, and that the output should also be
     an intermediate value, to be further aggregated later using
     INTERMEDIATE_TO_INTERMEDIATE or INTERMEDIATE_TO_RESULT.
    """

    INITIAL_TO_RESULT = 3
    """
    A complete invocation: the function should aggregate the given set of
     inputs to yield a single return value. This style must be used for
     aggregate or window functions that are not decomposable.
    """

    INTERMEDIATE_TO_RESULT = 4
    """
    Specifies that the inputs of the aggregate or window function are the
     intermediate values of the function, generated previously using
     INITIAL_TO_INTERMEDIATE and possibly INTERMEDIATE_TO_INTERMEDIATE calls.
     This call should combine the intermediate values to yield the final
     return value.
    """


class JoinRelJoinType(betterproto.Enum):
    JOIN_TYPE_UNSPECIFIED = 0
    JOIN_TYPE_INNER = 1
    JOIN_TYPE_OUTER = 2
    JOIN_TYPE_LEFT = 3
    JOIN_TYPE_RIGHT = 4
    JOIN_TYPE_SEMI = 5
    JOIN_TYPE_ANTI = 6
    JOIN_TYPE_SINGLE = 7
    """
    This join is useful for nested sub-queries where we need exactly one record in output (or throw exception)
     See Section 3.2 of https://15721.courses.cs.cmu.edu/spring2018/papers/16-optimizer2/hyperjoins-btw2017.pdf
    """


class SetRelSetOp(betterproto.Enum):
    SET_OP_UNSPECIFIED = 0
    SET_OP_MINUS_PRIMARY = 1
    SET_OP_MINUS_MULTISET = 2
    SET_OP_INTERSECTION_PRIMARY = 3
    SET_OP_INTERSECTION_MULTISET = 4
    SET_OP_UNION_DISTINCT = 5
    SET_OP_UNION_ALL = 6


class DdlRelDdlObject(betterproto.Enum):
    DDL_OBJECT_UNSPECIFIED = 0
    DDL_OBJECT_TABLE = 1
    """A Table object in the system"""

    DDL_OBJECT_VIEW = 2
    """A View object in the system"""


class DdlRelDdlOp(betterproto.Enum):
    DDL_OP_UNSPECIFIED = 0
    DDL_OP_CREATE = 1
    """A create operation (for any object)"""

    DDL_OP_CREATE_OR_REPLACE = 2
    """
    A create operation if the object does not exist, or replaces it (equivalent to a DROP + CREATE) if the object already exists
    """

    DDL_OP_ALTER = 3
    """
    An operation that modifies the schema (e.g., column names, types, default values) for the target object
    """

    DDL_OP_DROP = 4
    """An operation that removes an object from the system"""

    DDL_OP_DROP_IF_EXIST = 5
    """
    An operation that removes an object from the system (without throwing an exception if the object did not exist)
    """


class WriteRelWriteOp(betterproto.Enum):
    WRITE_OP_UNSPECIFIED = 0
    WRITE_OP_INSERT = 1
    """The insert of new records in a table"""

    WRITE_OP_DELETE = 2
    """The removal of records from a table"""

    WRITE_OP_UPDATE = 3
    """The modification of existing records within a table"""

    WRITE_OP_CTAS = 4
    """
    The Creation of a new table, and the insert of new records in the table
    """


class WriteRelOutputMode(betterproto.Enum):
    OUTPUT_MODE_UNSPECIFIED = 0
    OUTPUT_MODE_NO_OUTPUT = 1
    """return no records at all"""

    OUTPUT_MODE_MODIFIED_RECORDS = 2
    """
    this mode makes the operator return all the record INSERTED/DELETED/UPDATED by the operator.
     The operator returns the AFTER-image of any change. This can be further manipulated by operators upstreams
     (e.g., retunring the typical "count of modified records").
     For scenarios in which the BEFORE image is required, the user must implement a spool (via references to
     subplans in the body of the Rel input) and return those with anounter PlanRel.relations.
    """


class ComparisonJoinKeySimpleComparisonType(betterproto.Enum):
    """
    Most joins will use one of the following behaviors.  To avoid the complexity
     of a function lookup we define the common behaviors here
    """

    SIMPLE_COMPARISON_TYPE_UNSPECIFIED = 0
    SIMPLE_COMPARISON_TYPE_EQ = 1
    """Returns true only if both values are equal and not null"""

    SIMPLE_COMPARISON_TYPE_IS_NOT_DISTINCT_FROM = 2
    """
    Returns true if both values are equal and not null
     Returns true if both values are null
     Returns false if one value is null and the other value is not null
    
     This can be expressed as a = b OR (isnull(a) AND isnull(b))
    """

    SIMPLE_COMPARISON_TYPE_MIGHT_EQUAL = 3
    """
    Returns true if both values are equal and not null
     Returns true if either value is null
    
     This can be expressed as a = b OR isnull(a = b)
    """


class HashJoinRelJoinType(betterproto.Enum):
    JOIN_TYPE_UNSPECIFIED = 0
    JOIN_TYPE_INNER = 1
    JOIN_TYPE_OUTER = 2
    JOIN_TYPE_LEFT = 3
    JOIN_TYPE_RIGHT = 4
    JOIN_TYPE_LEFT_SEMI = 5
    JOIN_TYPE_RIGHT_SEMI = 6
    JOIN_TYPE_LEFT_ANTI = 7
    JOIN_TYPE_RIGHT_ANTI = 8


class MergeJoinRelJoinType(betterproto.Enum):
    JOIN_TYPE_UNSPECIFIED = 0
    JOIN_TYPE_INNER = 1
    JOIN_TYPE_OUTER = 2
    JOIN_TYPE_LEFT = 3
    JOIN_TYPE_RIGHT = 4
    JOIN_TYPE_LEFT_SEMI = 5
    JOIN_TYPE_RIGHT_SEMI = 6
    JOIN_TYPE_LEFT_ANTI = 7
    JOIN_TYPE_RIGHT_ANTI = 8


class NestedLoopJoinRelJoinType(betterproto.Enum):
    JOIN_TYPE_UNSPECIFIED = 0
    JOIN_TYPE_INNER = 1
    JOIN_TYPE_OUTER = 2
    JOIN_TYPE_LEFT = 3
    JOIN_TYPE_RIGHT = 4
    JOIN_TYPE_LEFT_SEMI = 5
    JOIN_TYPE_RIGHT_SEMI = 6
    JOIN_TYPE_LEFT_ANTI = 7
    JOIN_TYPE_RIGHT_ANTI = 8


class ExpressionWindowFunctionBoundsType(betterproto.Enum):
    BOUNDS_TYPE_UNSPECIFIED = 0
    BOUNDS_TYPE_ROWS = 1
    """
    The lower and upper bound specify how many rows before and after the current row
     the window should extend.
    """

    BOUNDS_TYPE_RANGE = 2
    """
    The lower and upper bound describe a range of values.  The window should include all rows
     where the value of the ordering column is greater than or equal to (current_value - lower bound)
     and less than or equal to (current_value + upper bound).  This bounds type is only valid if there
     is a single ordering column.
    """


class ExpressionCastFailureBehavior(betterproto.Enum):
    FAILURE_BEHAVIOR_UNSPECIFIED = 0
    FAILURE_BEHAVIOR_RETURN_NULL = 1
    FAILURE_BEHAVIOR_THROW_EXCEPTION = 2


class ExpressionSubquerySetPredicatePredicateOp(betterproto.Enum):
    PREDICATE_OP_UNSPECIFIED = 0
    PREDICATE_OP_EXISTS = 1
    PREDICATE_OP_UNIQUE = 2


class ExpressionSubquerySetComparisonComparisonOp(betterproto.Enum):
    COMPARISON_OP_UNSPECIFIED = 0
    COMPARISON_OP_EQ = 1
    COMPARISON_OP_NE = 2
    COMPARISON_OP_LT = 3
    COMPARISON_OP_GT = 4
    COMPARISON_OP_LE = 5
    COMPARISON_OP_GE = 6


class ExpressionSubquerySetComparisonReductionOp(betterproto.Enum):
    REDUCTION_OP_UNSPECIFIED = 0
    REDUCTION_OP_ANY = 1
    REDUCTION_OP_ALL = 2


class SortFieldSortDirection(betterproto.Enum):
    SORT_DIRECTION_UNSPECIFIED = 0
    SORT_DIRECTION_ASC_NULLS_FIRST = 1
    SORT_DIRECTION_ASC_NULLS_LAST = 2
    SORT_DIRECTION_DESC_NULLS_FIRST = 3
    SORT_DIRECTION_DESC_NULLS_LAST = 4
    SORT_DIRECTION_CLUSTERED = 5


class AggregateFunctionAggregationInvocation(betterproto.Enum):
    """
    Method in which equivalent records are merged before being aggregated.
    """

    AGGREGATION_INVOCATION_UNSPECIFIED = 0
    """This default value implies AGGREGATION_INVOCATION_ALL."""

    AGGREGATION_INVOCATION_ALL = 1
    """Use all values in the aggregation calculation."""

    AGGREGATION_INVOCATION_DISTINCT = 2
    """Use only distinct values in the aggregation calculation."""


class DerivationExpressionUnaryOpUnaryOpType(betterproto.Enum):
    UNARY_OP_TYPE_UNSPECIFIED = 0
    UNARY_OP_TYPE_BOOLEAN_NOT = 1


class DerivationExpressionBinaryOpBinaryOpType(betterproto.Enum):
    BINARY_OP_TYPE_UNSPECIFIED = 0
    BINARY_OP_TYPE_PLUS = 1
    BINARY_OP_TYPE_MINUS = 2
    BINARY_OP_TYPE_MULTIPLY = 3
    BINARY_OP_TYPE_DIVIDE = 4
    BINARY_OP_TYPE_MIN = 5
    BINARY_OP_TYPE_MAX = 6
    BINARY_OP_TYPE_GREATER_THAN = 7
    BINARY_OP_TYPE_LESS_THAN = 8
    BINARY_OP_TYPE_AND = 9
    BINARY_OP_TYPE_OR = 10
    BINARY_OP_TYPE_EQUALS = 11
    BINARY_OP_TYPE_COVERS = 12


class FunctionSignatureFinalArgVariadicParameterConsistency(betterproto.Enum):
    PARAMETER_CONSISTENCY_UNSPECIFIED = 0
    PARAMETER_CONSISTENCY_CONSISTENT = 1
    """All argument must be the same concrete type."""

    PARAMETER_CONSISTENCY_INCONSISTENT = 2
    """
    Each argument can be any possible concrete type afforded by the bounds
     of any parameter defined in the arguments specification.
    """


class FunctionSignatureWindowWindowType(betterproto.Enum):
    WINDOW_TYPE_UNSPECIFIED = 0
    WINDOW_TYPE_STREAMING = 1
    WINDOW_TYPE_PARTITION = 2


class FunctionSignatureImplementationType(betterproto.Enum):
    TYPE_UNSPECIFIED = 0
    TYPE_WEB_ASSEMBLY = 1
    TYPE_TRINO_JAR = 2


@dataclass(eq=False, repr=False)
class Type(betterproto.Message):
    bool: "TypeBoolean" = betterproto.message_field(1, group="kind")
    i8: "TypeI8" = betterproto.message_field(2, group="kind")
    i16: "TypeI16" = betterproto.message_field(3, group="kind")
    i32: "TypeI32" = betterproto.message_field(5, group="kind")
    i64: "TypeI64" = betterproto.message_field(7, group="kind")
    fp32: "TypeFp32" = betterproto.message_field(10, group="kind")
    fp64: "TypeFp64" = betterproto.message_field(11, group="kind")
    string: "TypeString" = betterproto.message_field(12, group="kind")
    binary: "TypeBinary" = betterproto.message_field(13, group="kind")
    timestamp: "TypeTimestamp" = betterproto.message_field(14, group="kind")
    """Deprecated in favor of `PrecisionTimestamp precision_timestamp`"""

    date: "TypeDate" = betterproto.message_field(16, group="kind")
    time: "TypeTime" = betterproto.message_field(17, group="kind")
    interval_year: "TypeIntervalYear" = betterproto.message_field(19, group="kind")
    interval_day: "TypeIntervalDay" = betterproto.message_field(20, group="kind")
    timestamp_tz: "TypeTimestampTz" = betterproto.message_field(29, group="kind")
    """Deprecated in favor of `PrecisionTimestampTZ precision_timestamp_tz`"""

    uuid: "TypeUuid" = betterproto.message_field(32, group="kind")
    fixed_char: "TypeFixedChar" = betterproto.message_field(21, group="kind")
    varchar: "TypeVarChar" = betterproto.message_field(22, group="kind")
    fixed_binary: "TypeFixedBinary" = betterproto.message_field(23, group="kind")
    decimal: "TypeDecimal" = betterproto.message_field(24, group="kind")
    precision_timestamp: "TypePrecisionTimestamp" = betterproto.message_field(
        33, group="kind"
    )
    precision_timestamp_tz: "TypePrecisionTimestampTz" = betterproto.message_field(
        34, group="kind"
    )
    struct: "TypeStruct" = betterproto.message_field(25, group="kind")
    list: "TypeList" = betterproto.message_field(27, group="kind")
    map: "TypeMap" = betterproto.message_field(28, group="kind")
    user_defined: "TypeUserDefined" = betterproto.message_field(30, group="kind")
    user_defined_type_reference: int = betterproto.uint32_field(31, group="kind")
    """
    Deprecated in favor of user_defined, which allows nullability and
     variations to be specified. If user_defined_type_reference is
     encountered, treat it as being non-nullable and having the default
     variation.
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("timestamp"):
            warnings.warn("Type.timestamp is deprecated", DeprecationWarning)
        if self.is_set("timestamp_tz"):
            warnings.warn("Type.timestamp_tz is deprecated", DeprecationWarning)
        if self.is_set("user_defined_type_reference"):
            warnings.warn(
                "Type.user_defined_type_reference is deprecated", DeprecationWarning
            )


@dataclass(eq=False, repr=False)
class TypeBoolean(betterproto.Message):
    type_variation_reference: int = betterproto.uint32_field(1)
    nullability: "TypeNullability" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class TypeI8(betterproto.Message):
    type_variation_reference: int = betterproto.uint32_field(1)
    nullability: "TypeNullability" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class TypeI16(betterproto.Message):
    type_variation_reference: int = betterproto.uint32_field(1)
    nullability: "TypeNullability" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class TypeI32(betterproto.Message):
    type_variation_reference: int = betterproto.uint32_field(1)
    nullability: "TypeNullability" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class TypeI64(betterproto.Message):
    type_variation_reference: int = betterproto.uint32_field(1)
    nullability: "TypeNullability" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class TypeFp32(betterproto.Message):
    type_variation_reference: int = betterproto.uint32_field(1)
    nullability: "TypeNullability" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class TypeFp64(betterproto.Message):
    type_variation_reference: int = betterproto.uint32_field(1)
    nullability: "TypeNullability" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class TypeString(betterproto.Message):
    type_variation_reference: int = betterproto.uint32_field(1)
    nullability: "TypeNullability" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class TypeBinary(betterproto.Message):
    type_variation_reference: int = betterproto.uint32_field(1)
    nullability: "TypeNullability" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class TypeTimestamp(betterproto.Message):
    type_variation_reference: int = betterproto.uint32_field(1)
    nullability: "TypeNullability" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class TypeDate(betterproto.Message):
    type_variation_reference: int = betterproto.uint32_field(1)
    nullability: "TypeNullability" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class TypeTime(betterproto.Message):
    type_variation_reference: int = betterproto.uint32_field(1)
    nullability: "TypeNullability" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class TypeTimestampTz(betterproto.Message):
    type_variation_reference: int = betterproto.uint32_field(1)
    nullability: "TypeNullability" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class TypeIntervalYear(betterproto.Message):
    type_variation_reference: int = betterproto.uint32_field(1)
    nullability: "TypeNullability" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class TypeIntervalDay(betterproto.Message):
    type_variation_reference: int = betterproto.uint32_field(1)
    nullability: "TypeNullability" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class TypeUuid(betterproto.Message):
    type_variation_reference: int = betterproto.uint32_field(1)
    nullability: "TypeNullability" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class TypeFixedChar(betterproto.Message):
    """Start compound types."""

    length: int = betterproto.int32_field(1)
    type_variation_reference: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class TypeVarChar(betterproto.Message):
    length: int = betterproto.int32_field(1)
    type_variation_reference: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class TypeFixedBinary(betterproto.Message):
    length: int = betterproto.int32_field(1)
    type_variation_reference: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class TypeDecimal(betterproto.Message):
    scale: int = betterproto.int32_field(1)
    precision: int = betterproto.int32_field(2)
    type_variation_reference: int = betterproto.uint32_field(3)
    nullability: "TypeNullability" = betterproto.enum_field(4)


@dataclass(eq=False, repr=False)
class TypePrecisionTimestamp(betterproto.Message):
    precision: int = betterproto.int32_field(1)
    """Defaults to 6"""

    type_variation_reference: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class TypePrecisionTimestampTz(betterproto.Message):
    precision: int = betterproto.int32_field(1)
    """Defaults to 6"""

    type_variation_reference: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class TypeStruct(betterproto.Message):
    types: List["Type"] = betterproto.message_field(1)
    type_variation_reference: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class TypeList(betterproto.Message):
    type: "Type" = betterproto.message_field(1)
    type_variation_reference: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class TypeMap(betterproto.Message):
    key: "Type" = betterproto.message_field(1)
    value: "Type" = betterproto.message_field(2)
    type_variation_reference: int = betterproto.uint32_field(3)
    nullability: "TypeNullability" = betterproto.enum_field(4)


@dataclass(eq=False, repr=False)
class TypeUserDefined(betterproto.Message):
    type_reference: int = betterproto.uint32_field(1)
    type_variation_reference: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)
    type_parameters: List["TypeParameter"] = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class TypeParameter(betterproto.Message):
    null: "betterproto_lib_google_protobuf.Empty" = betterproto.message_field(
        1, group="parameter"
    )
    """
    Explicitly null/unspecified parameter, to select the default value (if
     any).
    """

    data_type: "Type" = betterproto.message_field(2, group="parameter")
    """Data type parameters, like the i32 in LIST<i32>."""

    boolean: bool = betterproto.bool_field(3, group="parameter")
    """Value parameters, like the 10 in VARCHAR<10>."""

    integer: int = betterproto.int64_field(4, group="parameter")
    enum: str = betterproto.string_field(5, group="parameter")
    string: str = betterproto.string_field(6, group="parameter")


@dataclass(eq=False, repr=False)
class NamedStruct(betterproto.Message):
    """
    A message for modeling name/type pairs.

     Useful for representing relation schemas.

     Notes:

     * The names field is in depth-first order.

     For example a schema such as:

     a: int64
     b: struct<c: float32, d: string>

     would have a `names` field that looks like:

     ["a", "b", "c", "d"]

     * Only struct fields are contained in this field's elements,
     * Map keys should be traversed first, then values when producing/consuming
    """

    names: List[str] = betterproto.string_field(1)
    """list of names in dfs order"""

    struct: "TypeStruct" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class RelCommon(betterproto.Message):
    """Common fields for all relational operators"""

    direct: "RelCommonDirect" = betterproto.message_field(1, group="emit_kind")
    """
    The underlying relation is output as is (no reordering or projection of columns)
    """

    emit: "RelCommonEmit" = betterproto.message_field(2, group="emit_kind")
    """Allows to control for order and inclusion of fields"""

    hint: "RelCommonHint" = betterproto.message_field(3)
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class RelCommonDirect(betterproto.Message):
    """
    Direct indicates no change on presence and ordering of fields in the output
    """

    pass


@dataclass(eq=False, repr=False)
class RelCommonEmit(betterproto.Message):
    """Remap which fields are output and in which order"""

    output_mapping: List[int] = betterproto.int32_field(1)


@dataclass(eq=False, repr=False)
class RelCommonHint(betterproto.Message):
    """
    Changes to the operation that can influence efficiency/performance but
     should not impact correctness.
    """

    stats: "RelCommonHintStats" = betterproto.message_field(1)
    constraint: "RelCommonHintRuntimeConstraint" = betterproto.message_field(2)
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class RelCommonHintStats(betterproto.Message):
    """The statistics related to a hint (physical properties of records)"""

    row_count: float = betterproto.double_field(1)
    record_size: float = betterproto.double_field(2)
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class RelCommonHintRuntimeConstraint(betterproto.Message):
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class ReadRel(betterproto.Message):
    """
    The scan operator of base data (physical or virtual), including filtering and projection.
    """

    common: "RelCommon" = betterproto.message_field(1)
    base_schema: "NamedStruct" = betterproto.message_field(2)
    filter: "Expression" = betterproto.message_field(3)
    best_effort_filter: "Expression" = betterproto.message_field(11)
    projection: "ExpressionMaskExpression" = betterproto.message_field(4)
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)
    virtual_table: "ReadRelVirtualTable" = betterproto.message_field(
        5, group="read_type"
    )
    local_files: "ReadRelLocalFiles" = betterproto.message_field(6, group="read_type")
    named_table: "ReadRelNamedTable" = betterproto.message_field(7, group="read_type")
    extension_table: "ReadRelExtensionTable" = betterproto.message_field(
        8, group="read_type"
    )


@dataclass(eq=False, repr=False)
class ReadRelNamedTable(betterproto.Message):
    """
    A base table. The list of string is used to represent namespacing (e.g., mydb.mytable).
     This assumes shared catalog between systems exchanging a message.
    """

    names: List[str] = betterproto.string_field(1)
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class ReadRelVirtualTable(betterproto.Message):
    """A table composed of literals."""

    values: List["ExpressionLiteralStruct"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ReadRelExtensionTable(betterproto.Message):
    """
    A stub type that can be used to extend/introduce new table types outside
     the specification.
    """

    detail: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ReadRelLocalFiles(betterproto.Message):
    """Represents a list of files in input of a scan operation"""

    items: List["ReadRelLocalFilesFileOrFiles"] = betterproto.message_field(1)
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class ReadRelLocalFilesFileOrFiles(betterproto.Message):
    """
    Many files consist of indivisible chunks (e.g. parquet row groups
     or CSV rows).  If a slice partially selects an indivisible chunk
     then the consumer should employ some rule to decide which slice to
     include the chunk in (e.g. include it in the slice that contains
     the midpoint of the chunk)
    """

    uri_path: str = betterproto.string_field(1, group="path_type")
    """A URI that can refer to either a single folder or a single file"""

    uri_path_glob: str = betterproto.string_field(2, group="path_type")
    """
    A URI where the path portion is a glob expression that can
     identify zero or more paths.
     Consumers should support the POSIX syntax.  The recursive
     globstar (**) may not be supported.
    """

    uri_file: str = betterproto.string_field(3, group="path_type")
    """A URI that refers to a single file"""

    uri_folder: str = betterproto.string_field(4, group="path_type")
    """A URI that refers to a single folder"""

    partition_index: int = betterproto.uint64_field(6)
    """The index of the partition this item belongs to"""

    start: int = betterproto.uint64_field(7)
    """The start position in byte to read from this item"""

    length: int = betterproto.uint64_field(8)
    """The length in byte to read from this item"""

    parquet: "ReadRelLocalFilesFileOrFilesParquetReadOptions" = (
        betterproto.message_field(9, group="file_format")
    )
    arrow: "ReadRelLocalFilesFileOrFilesArrowReadOptions" = betterproto.message_field(
        10, group="file_format"
    )
    orc: "ReadRelLocalFilesFileOrFilesOrcReadOptions" = betterproto.message_field(
        11, group="file_format"
    )
    extension: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        12, group="file_format"
    )
    dwrf: "ReadRelLocalFilesFileOrFilesDwrfReadOptions" = betterproto.message_field(
        13, group="file_format"
    )


@dataclass(eq=False, repr=False)
class ReadRelLocalFilesFileOrFilesParquetReadOptions(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ReadRelLocalFilesFileOrFilesArrowReadOptions(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ReadRelLocalFilesFileOrFilesOrcReadOptions(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ReadRelLocalFilesFileOrFilesDwrfReadOptions(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ProjectRel(betterproto.Message):
    """
    This operator allows to represent calculated expressions of fields (e.g., a+b). Direct/Emit are used to represent classical relational projections
    """

    common: "RelCommon" = betterproto.message_field(1)
    input: "Rel" = betterproto.message_field(2)
    expressions: List["Expression"] = betterproto.message_field(3)
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class JoinRel(betterproto.Message):
    """
    The binary JOIN relational operator left-join-right, including various join types, a join condition and post_join_filter expression
    """

    common: "RelCommon" = betterproto.message_field(1)
    left: "Rel" = betterproto.message_field(2)
    right: "Rel" = betterproto.message_field(3)
    expression: "Expression" = betterproto.message_field(4)
    post_join_filter: "Expression" = betterproto.message_field(5)
    type: "JoinRelJoinType" = betterproto.enum_field(6)
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class CrossRel(betterproto.Message):
    """Cartesian product relational operator of two tables (left and right)"""

    common: "RelCommon" = betterproto.message_field(1)
    left: "Rel" = betterproto.message_field(2)
    right: "Rel" = betterproto.message_field(3)
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class FetchRel(betterproto.Message):
    """
    The relational operator representing LIMIT/OFFSET or TOP type semantics.
    """

    common: "RelCommon" = betterproto.message_field(1)
    input: "Rel" = betterproto.message_field(2)
    offset: int = betterproto.int64_field(3)
    """the offset expressed in number of records"""

    count: int = betterproto.int64_field(4)
    """
    the amount of records to return
     use -1 to signal that ALL records should be returned
    """

    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class AggregateRel(betterproto.Message):
    """The relational operator representing a GROUP BY Aggregate"""

    common: "RelCommon" = betterproto.message_field(1)
    input: "Rel" = betterproto.message_field(2)
    """Input of the aggregation"""

    groupings: List["AggregateRelGrouping"] = betterproto.message_field(3)
    """
    A list of one or more grouping expression sets that the aggregation measures should be calculated for.
     Required if there are no measures.
    """

    measures: List["AggregateRelMeasure"] = betterproto.message_field(4)
    """
    A list of one or more aggregate expressions along with an optional filter.
     Required if there are no groupings.
    """

    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class AggregateRelGrouping(betterproto.Message):
    grouping_expressions: List["Expression"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class AggregateRelMeasure(betterproto.Message):
    measure: "AggregateFunction" = betterproto.message_field(1)
    filter: "Expression" = betterproto.message_field(2)
    """
    An optional boolean expression that acts to filter which records are
     included in the measure. True means include this record for calculation
     within the measure.
     Helps to support SUM(<c>) FILTER(WHERE...) syntax without masking opportunities for optimization
    """


@dataclass(eq=False, repr=False)
class ConsistentPartitionWindowRel(betterproto.Message):
    """
    ConsistentPartitionWindowRel provides the ability to perform calculations across sets of rows
     that are related to the current query row. It can be used to execute window functions where
     all the windows share the same partitioning and ordering.
    """

    common: "RelCommon" = betterproto.message_field(1)
    input: "Rel" = betterproto.message_field(2)
    window_functions: List["ConsistentPartitionWindowRelWindowRelFunction"] = (
        betterproto.message_field(3)
    )
    partition_expressions: List["Expression"] = betterproto.message_field(4)
    sorts: List["SortField"] = betterproto.message_field(5)
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class ConsistentPartitionWindowRelWindowRelFunction(betterproto.Message):
    """
    This message mirrors the `WindowFunction` message but removes the fields defining the partition,
     sorts, and bounds, since those must be consistent across the various functions in this rel.  Refer
     to the `WindowFunction` message for a description of these fields.
    """

    function_reference: int = betterproto.uint32_field(1)
    arguments: List["FunctionArgument"] = betterproto.message_field(9)
    options: List["FunctionOption"] = betterproto.message_field(11)
    output_type: "Type" = betterproto.message_field(7)
    phase: "AggregationPhase" = betterproto.enum_field(6)
    invocation: "AggregateFunctionAggregationInvocation" = betterproto.enum_field(10)
    lower_bound: "ExpressionWindowFunctionBound" = betterproto.message_field(5)
    upper_bound: "ExpressionWindowFunctionBound" = betterproto.message_field(4)
    bounds_type: "ExpressionWindowFunctionBoundsType" = betterproto.enum_field(12)


@dataclass(eq=False, repr=False)
class SortRel(betterproto.Message):
    """
    The ORDERY BY (or sorting) relational operator. Beside describing a base relation, it includes a list of fields to sort on
    """

    common: "RelCommon" = betterproto.message_field(1)
    input: "Rel" = betterproto.message_field(2)
    sorts: List["SortField"] = betterproto.message_field(3)
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class FilterRel(betterproto.Message):
    """
    The relational operator capturing simple FILTERs (as in the WHERE clause of SQL)
    """

    common: "RelCommon" = betterproto.message_field(1)
    input: "Rel" = betterproto.message_field(2)
    condition: "Expression" = betterproto.message_field(3)
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class SetRel(betterproto.Message):
    """The relational set operators (intersection/union/etc..)"""

    common: "RelCommon" = betterproto.message_field(1)
    inputs: List["Rel"] = betterproto.message_field(2)
    """
    The first input is the primary input, the remaining are secondary
     inputs.  There must be at least two inputs.
    """

    op: "SetRelSetOp" = betterproto.enum_field(3)
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class ExtensionSingleRel(betterproto.Message):
    """Stub to support extension with a single input"""

    common: "RelCommon" = betterproto.message_field(1)
    input: "Rel" = betterproto.message_field(2)
    detail: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class ExtensionLeafRel(betterproto.Message):
    """Stub to support extension with a zero inputs"""

    common: "RelCommon" = betterproto.message_field(1)
    detail: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ExtensionMultiRel(betterproto.Message):
    """Stub to support extension with multiple inputs"""

    common: "RelCommon" = betterproto.message_field(1)
    inputs: List["Rel"] = betterproto.message_field(2)
    detail: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class ExchangeRel(betterproto.Message):
    """A redistribution operation"""

    common: "RelCommon" = betterproto.message_field(1)
    input: "Rel" = betterproto.message_field(2)
    partition_count: int = betterproto.int32_field(3)
    targets: List["ExchangeRelExchangeTarget"] = betterproto.message_field(4)
    scatter_by_fields: "ExchangeRelScatterFields" = betterproto.message_field(
        5, group="exchange_kind"
    )
    single_target: "ExchangeRelSingleBucketExpression" = betterproto.message_field(
        6, group="exchange_kind"
    )
    multi_target: "ExchangeRelMultiBucketExpression" = betterproto.message_field(
        7, group="exchange_kind"
    )
    round_robin: "ExchangeRelRoundRobin" = betterproto.message_field(
        8, group="exchange_kind"
    )
    broadcast: "ExchangeRelBroadcast" = betterproto.message_field(
        9, group="exchange_kind"
    )
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class ExchangeRelScatterFields(betterproto.Message):
    fields: List["ExpressionFieldReference"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ExchangeRelSingleBucketExpression(betterproto.Message):
    """Returns a single bucket number per record."""

    expression: "Expression" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ExchangeRelMultiBucketExpression(betterproto.Message):
    """Returns zero or more bucket numbers per record"""

    expression: "Expression" = betterproto.message_field(1)
    constrained_to_count: bool = betterproto.bool_field(2)


@dataclass(eq=False, repr=False)
class ExchangeRelBroadcast(betterproto.Message):
    """Send all data to every target."""

    pass


@dataclass(eq=False, repr=False)
class ExchangeRelRoundRobin(betterproto.Message):
    """Route approximately"""

    exact: bool = betterproto.bool_field(1)
    """
    whether the round robin behavior is required to exact (per record) or
     approximate. Defaults to approximate.
    """


@dataclass(eq=False, repr=False)
class ExchangeRelExchangeTarget(betterproto.Message):
    """The message to describe partition targets of an exchange"""

    partition_id: List[int] = betterproto.int32_field(1)
    """
    Describes the partition id(s) to send. If this is empty, all data is sent
     to this target.
    """

    uri: str = betterproto.string_field(2, group="target_type")
    extended: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        3, group="target_type"
    )


@dataclass(eq=False, repr=False)
class ExpandRel(betterproto.Message):
    """
    Duplicates records by emitting one or more rows per input row.  The number of rows emitted per
     input row is the same for all input rows.

     In addition to a field being emitted per input field an extra int64 field is emitted which
     contains a zero-indexed ordinal corresponding to the duplicate definition.
    """

    common: "RelCommon" = betterproto.message_field(1)
    input: "Rel" = betterproto.message_field(2)
    fields: List["ExpandRelExpandField"] = betterproto.message_field(4)
    """
    There should be one definition here for each input field.  Any fields beyond the provided
     definitions will be emitted as is (as if a consistent_field record with an identity
     expression was provided).
    """


@dataclass(eq=False, repr=False)
class ExpandRelExpandField(betterproto.Message):
    switching_field: "ExpandRelSwitchingField" = betterproto.message_field(
        2, group="field_type"
    )
    """
    Field that switches output based on which duplicate is being output.  Every
     switching_field should contain the same number of duplicates (so that the output rows
     are of consistent size and type).  If there are not enough switching field definitions
     to match the other field definitions NULL will be returned to fill the extras.
    """

    consistent_field: "Expression" = betterproto.message_field(3, group="field_type")
    """
    Field that outputs the same value no matter which duplicate is being output.  Equivalent
     to a switching_field that lists the same expression multiple times.
    """


@dataclass(eq=False, repr=False)
class ExpandRelSwitchingField(betterproto.Message):
    duplicates: List["Expression"] = betterproto.message_field(1)
    """
    All duplicates must return the same type class but may differ in nullability.  The effective
     type of the output field will be nullable if any of the duplicate expressions are nullable.
    """


@dataclass(eq=False, repr=False)
class RelRoot(betterproto.Message):
    """
    A relation with output field names.

     This is for use at the root of a `Rel` tree.
    """

    input: "Rel" = betterproto.message_field(1)
    """A relation"""

    names: List[str] = betterproto.string_field(2)
    """Field names in depth-first order"""


@dataclass(eq=False, repr=False)
class Rel(betterproto.Message):
    """A relation (used internally in a plan)"""

    read: "ReadRel" = betterproto.message_field(1, group="rel_type")
    filter: "FilterRel" = betterproto.message_field(2, group="rel_type")
    fetch: "FetchRel" = betterproto.message_field(3, group="rel_type")
    aggregate: "AggregateRel" = betterproto.message_field(4, group="rel_type")
    sort: "SortRel" = betterproto.message_field(5, group="rel_type")
    join: "JoinRel" = betterproto.message_field(6, group="rel_type")
    project: "ProjectRel" = betterproto.message_field(7, group="rel_type")
    set: "SetRel" = betterproto.message_field(8, group="rel_type")
    extension_single: "ExtensionSingleRel" = betterproto.message_field(
        9, group="rel_type"
    )
    extension_multi: "ExtensionMultiRel" = betterproto.message_field(
        10, group="rel_type"
    )
    extension_leaf: "ExtensionLeafRel" = betterproto.message_field(11, group="rel_type")
    cross: "CrossRel" = betterproto.message_field(12, group="rel_type")
    reference: "ReferenceRel" = betterproto.message_field(21, group="rel_type")
    write: "WriteRel" = betterproto.message_field(19, group="rel_type")
    ddl: "DdlRel" = betterproto.message_field(20, group="rel_type")
    hash_join: "HashJoinRel" = betterproto.message_field(13, group="rel_type")
    """Physical relations"""

    merge_join: "MergeJoinRel" = betterproto.message_field(14, group="rel_type")
    nested_loop_join: "NestedLoopJoinRel" = betterproto.message_field(
        18, group="rel_type"
    )
    window: "ConsistentPartitionWindowRel" = betterproto.message_field(
        17, group="rel_type"
    )
    exchange: "ExchangeRel" = betterproto.message_field(15, group="rel_type")
    expand: "ExpandRel" = betterproto.message_field(16, group="rel_type")


@dataclass(eq=False, repr=False)
class NamedObjectWrite(betterproto.Message):
    """A base object for writing (e.g., a table or a view)."""

    names: List[str] = betterproto.string_field(1)
    """
    The list of string is used to represent namespacing (e.g., mydb.mytable).
     This assumes shared catalog between systems exchanging a message.
    """

    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class ExtensionObject(betterproto.Message):
    """
    A stub type that can be used to extend/introduce new table types outside
     the specification.
    """

    detail: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class DdlRel(betterproto.Message):
    named_object: "NamedObjectWrite" = betterproto.message_field(1, group="write_type")
    extension_object: "ExtensionObject" = betterproto.message_field(
        2, group="write_type"
    )
    table_schema: "NamedStruct" = betterproto.message_field(3)
    """
    The columns that will be modified (representing after-image of a schema change)
    """

    table_defaults: "ExpressionLiteralStruct" = betterproto.message_field(4)
    """
    The default values for the columns (representing after-image of a schema change)
     E.g., in case of an ALTER TABLE that changes some of the column default values, we expect
     the table_defaults Struct to report a full list of default values reflecting the result of applying
     the ALTER TABLE operator successfully
    """

    object: "DdlRelDdlObject" = betterproto.enum_field(5)
    """Which type of object we operate on"""

    op: "DdlRelDdlOp" = betterproto.enum_field(6)
    """The type of operation to perform"""

    view_definition: "Rel" = betterproto.message_field(7)
    """The body of the CREATE VIEW"""

    common: "RelCommon" = betterproto.message_field(8)


@dataclass(eq=False, repr=False)
class WriteRel(betterproto.Message):
    """
    The operator that modifies the content of a database (operates on 1 table at a time, but record-selection/source can be
     based on joining of multiple tables).
    """

    named_table: "NamedObjectWrite" = betterproto.message_field(1, group="write_type")
    extension_table: "ExtensionObject" = betterproto.message_field(
        2, group="write_type"
    )
    table_schema: "NamedStruct" = betterproto.message_field(3)
    """
    The schema of the table (must align with Rel input (e.g., number of leaf fields must match))
    """

    op: "WriteRelWriteOp" = betterproto.enum_field(4)
    """The type of operation to perform"""

    input: "Rel" = betterproto.message_field(5)
    """
    The relation that determines the records to add/remove/modify
     the schema must match with table_schema. Default values must be explicitly stated
     in a ProjectRel at the top of the input. The match must also
     occur in case of DELETE to ensure multi-engine plans are unequivocal.
    """

    output: "WriteRelOutputMode" = betterproto.enum_field(6)
    """Output mode determines what is the output of executing this rel"""

    common: "RelCommon" = betterproto.message_field(7)


@dataclass(eq=False, repr=False)
class ComparisonJoinKey(betterproto.Message):
    """
    Hash joins and merge joins are a specialization of the general join where the join
     expression is an series of comparisons between fields that are ANDed together.  The
     behavior of this comparison is flexible
    """

    left: "ExpressionFieldReference" = betterproto.message_field(1)
    """The key to compare from the left table"""

    right: "ExpressionFieldReference" = betterproto.message_field(2)
    """The key to compare from the right table"""

    comparison: "ComparisonJoinKeyComparisonType" = betterproto.message_field(3)
    """Describes how to compare the two keys"""


@dataclass(eq=False, repr=False)
class ComparisonJoinKeyComparisonType(betterproto.Message):
    """Describes how the relation should consider if two rows are a match"""

    simple: "ComparisonJoinKeySimpleComparisonType" = betterproto.enum_field(
        1, group="inner_type"
    )
    """One of the simple comparison behaviors is used"""

    custom_function_reference: int = betterproto.uint32_field(2, group="inner_type")
    """
    A custom comparison behavior is used.  This can happen, for example, when using
     collations, where we might want to do something like a case-insensitive comparison.
    
     This must be a binary function with a boolean return type
    """


@dataclass(eq=False, repr=False)
class HashJoinRel(betterproto.Message):
    """
    The hash equijoin join operator will build a hash table out of the right input based on a set of join keys.
     It will then probe that hash table for incoming inputs, finding matches.

     Two rows are a match if the comparison function returns true for all keys
    """

    common: "RelCommon" = betterproto.message_field(1)
    left: "Rel" = betterproto.message_field(2)
    right: "Rel" = betterproto.message_field(3)
    left_keys: List["ExpressionFieldReference"] = betterproto.message_field(4)
    """
    These fields are deprecated in favor of `keys`.  If they are set then
     the two lists (left_keys and right_keys) must have the same length and
     the comparion function is considered to be SimpleEqualityType::EQ
    """

    right_keys: List["ExpressionFieldReference"] = betterproto.message_field(5)
    keys: List["ComparisonJoinKey"] = betterproto.message_field(8)
    """
    One or more keys to join on.  The relation is invalid if this is empty
     (unless the deprecated left_keys/right_keys fields are being used).
    
     If a custom comparison function is used then it must be consistent with
     the hash function used for the keys.
    
     In other words, the hash function must return the same hash code when the
     comparison returns true.  For example, if the comparison function is
     "equals ignoring case" then the hash function must return the same hash
     code for strings that differ only by case.  Note: the hash function is not
     specified here.  It is the responsibility of the consumer to find an appropriate
     hash function for a given comparsion function or to reject the plan if it cannot
     do so.
    """

    post_join_filter: "Expression" = betterproto.message_field(6)
    type: "HashJoinRelJoinType" = betterproto.enum_field(7)
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("left_keys"):
            warnings.warn("HashJoinRel.left_keys is deprecated", DeprecationWarning)
        if self.is_set("right_keys"):
            warnings.warn("HashJoinRel.right_keys is deprecated", DeprecationWarning)


@dataclass(eq=False, repr=False)
class MergeJoinRel(betterproto.Message):
    """
    The merge equijoin does a join by taking advantage of two sets that are sorted on the join keys.
     This allows the join operation to be done in a streaming fashion.
    """

    common: "RelCommon" = betterproto.message_field(1)
    left: "Rel" = betterproto.message_field(2)
    right: "Rel" = betterproto.message_field(3)
    left_keys: List["ExpressionFieldReference"] = betterproto.message_field(4)
    """
    These fields are deprecated in favor of `keys`.  If they are set then
     the two lists (left_keys and right_keys) must have the same length and
     the comparion function is considered to be SimpleEqualityType::EQ
    """

    right_keys: List["ExpressionFieldReference"] = betterproto.message_field(5)
    keys: List["ComparisonJoinKey"] = betterproto.message_field(8)
    """
    One or more keys to join on.  The relation is invalid if this is empty
     (unless the deprecated left_keys/right_keys fields are being used).
    
     If a custom comparison function is used then it must be consistent with
     the ordering of the input data.  For example, if the comparison function
     is "<" then we generally expect the data to be sorted in ascending order.
    
     If the comparison function is something like "less than ignoring case" then
     the data should be sorted appropriately (e.g. both "A" and "a" should come
     before "b")
    
     The sort order is not specified here.  It is typically the responsibility of
     the producer to ensure the plan sorts the data if needed (although the consumer
     is free to do so as well).  If possible, the consumer should verify the sort
     order and reject invalid plans.
    """

    post_join_filter: "Expression" = betterproto.message_field(6)
    type: "MergeJoinRelJoinType" = betterproto.enum_field(7)
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("left_keys"):
            warnings.warn("MergeJoinRel.left_keys is deprecated", DeprecationWarning)
        if self.is_set("right_keys"):
            warnings.warn("MergeJoinRel.right_keys is deprecated", DeprecationWarning)


@dataclass(eq=False, repr=False)
class NestedLoopJoinRel(betterproto.Message):
    """
    The nested loop join (NLJ) operator will hold the entire right input and iterate over it using the
     left input, evaluating the join expression on the Cartesian product of all rows.
    """

    common: "RelCommon" = betterproto.message_field(1)
    left: "Rel" = betterproto.message_field(2)
    right: "Rel" = betterproto.message_field(3)
    expression: "Expression" = betterproto.message_field(4)
    """optional, defaults to true (a cartesian join)"""

    type: "NestedLoopJoinRelJoinType" = betterproto.enum_field(5)
    advanced_extension: "extensions.AdvancedExtension" = betterproto.message_field(10)


@dataclass(eq=False, repr=False)
class FunctionArgument(betterproto.Message):
    """The argument of a function"""

    enum: str = betterproto.string_field(1, group="arg_type")
    type: "Type" = betterproto.message_field(2, group="arg_type")
    value: "Expression" = betterproto.message_field(3, group="arg_type")


@dataclass(eq=False, repr=False)
class FunctionOption(betterproto.Message):
    """
    An optional function argument.  Typically used for specifying behavior in
     invalid or corner cases.
    """

    name: str = betterproto.string_field(1)
    """
    Name of the option to set. If the consumer does not recognize the
     option, it must reject the plan. The name is matched case-insensitively
     with option names defined for the function.
    """

    preference: List[str] = betterproto.string_field(2)
    """
    List of behavior options allowed by the producer. At least one must be
     specified; to leave an option unspecified, simply don't add an entry to
     `options`. The consumer must use the first option from the list that it
     supports. If the consumer supports none of the specified options, it
     must reject the plan. The name is matched case-insensitively and must
     match one of the option values defined for the option.
    """


@dataclass(eq=False, repr=False)
class Expression(betterproto.Message):
    literal: "ExpressionLiteral" = betterproto.message_field(1, group="rex_type")
    selection: "ExpressionFieldReference" = betterproto.message_field(
        2, group="rex_type"
    )
    scalar_function: "ExpressionScalarFunction" = betterproto.message_field(
        3, group="rex_type"
    )
    window_function: "ExpressionWindowFunction" = betterproto.message_field(
        5, group="rex_type"
    )
    if_then: "ExpressionIfThen" = betterproto.message_field(6, group="rex_type")
    switch_expression: "ExpressionSwitchExpression" = betterproto.message_field(
        7, group="rex_type"
    )
    singular_or_list: "ExpressionSingularOrList" = betterproto.message_field(
        8, group="rex_type"
    )
    multi_or_list: "ExpressionMultiOrList" = betterproto.message_field(
        9, group="rex_type"
    )
    cast: "ExpressionCast" = betterproto.message_field(11, group="rex_type")
    subquery: "ExpressionSubquery" = betterproto.message_field(12, group="rex_type")
    nested: "ExpressionNested" = betterproto.message_field(13, group="rex_type")
    enum: "ExpressionEnum" = betterproto.message_field(10, group="rex_type")
    """
    deprecated: enum literals are only sensible in the context of
     function arguments, for which FunctionArgument should now be
     used
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("enum"):
            warnings.warn("Expression.enum is deprecated", DeprecationWarning)


@dataclass(eq=False, repr=False)
class ExpressionEnum(betterproto.Message):
    specified: str = betterproto.string_field(1, group="enum_kind")
    unspecified: "ExpressionEnumEmpty" = betterproto.message_field(2, group="enum_kind")

    def __post_init__(self) -> None:
        warnings.warn("ExpressionEnum is deprecated", DeprecationWarning)
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ExpressionEnumEmpty(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        warnings.warn("ExpressionEnumEmpty is deprecated", DeprecationWarning)
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ExpressionLiteral(betterproto.Message):
    boolean: bool = betterproto.bool_field(1, group="literal_type")
    i8: int = betterproto.int32_field(2, group="literal_type")
    i16: int = betterproto.int32_field(3, group="literal_type")
    i32: int = betterproto.int32_field(5, group="literal_type")
    i64: int = betterproto.int64_field(7, group="literal_type")
    fp32: float = betterproto.float_field(10, group="literal_type")
    fp64: float = betterproto.double_field(11, group="literal_type")
    string: str = betterproto.string_field(12, group="literal_type")
    binary: bytes = betterproto.bytes_field(13, group="literal_type")
    timestamp: int = betterproto.int64_field(14, group="literal_type")
    """
    Timestamp in units of microseconds since the UNIX epoch.
     Deprecated in favor of `precision_timestamp`
    """

    date: int = betterproto.int32_field(16, group="literal_type")
    """Date in units of days since the UNIX epoch."""

    time: int = betterproto.int64_field(17, group="literal_type")
    """Time in units of microseconds past midnight"""

    interval_year_to_month: "ExpressionLiteralIntervalYearToMonth" = (
        betterproto.message_field(19, group="literal_type")
    )
    interval_day_to_second: "ExpressionLiteralIntervalDayToSecond" = (
        betterproto.message_field(20, group="literal_type")
    )
    fixed_char: str = betterproto.string_field(21, group="literal_type")
    var_char: "ExpressionLiteralVarChar" = betterproto.message_field(
        22, group="literal_type"
    )
    fixed_binary: bytes = betterproto.bytes_field(23, group="literal_type")
    decimal: "ExpressionLiteralDecimal" = betterproto.message_field(
        24, group="literal_type"
    )
    precision_timestamp: int = betterproto.uint64_field(34, group="literal_type")
    """
    If the precision is 6 or less then this is the microseconds since the UNIX epoch
     If the precision is more than 6 then this is the nanoseconds since the UNIX epoch
    """

    precision_timestamp_tz: int = betterproto.uint64_field(35, group="literal_type")
    struct: "ExpressionLiteralStruct" = betterproto.message_field(
        25, group="literal_type"
    )
    map: "ExpressionLiteralMap" = betterproto.message_field(26, group="literal_type")
    timestamp_tz: int = betterproto.int64_field(27, group="literal_type")
    """
    Timestamp in units of microseconds since the UNIX epoch.
     Deprecated in favor of `precision_timestamp_tz`
    """

    uuid: bytes = betterproto.bytes_field(28, group="literal_type")
    null: "Type" = betterproto.message_field(29, group="literal_type")
    list: "ExpressionLiteralList" = betterproto.message_field(30, group="literal_type")
    empty_list: "TypeList" = betterproto.message_field(31, group="literal_type")
    empty_map: "TypeMap" = betterproto.message_field(32, group="literal_type")
    user_defined: "ExpressionLiteralUserDefined" = betterproto.message_field(
        33, group="literal_type"
    )
    nullable: bool = betterproto.bool_field(50)
    """
    Whether the literal_type above should be treated as a nullable type.
     Applies to all members of the literal_type oneof EXCEPT:
      * Type null             (must be nullable by definition)
      * Type.List empty_list  (use Type.List::nullability)
      * Type.Map empty_map    (use Type.Map::nullability)
    """

    type_variation_reference: int = betterproto.uint32_field(51)
    """
    optionally points to a type_variation_anchor defined in this plan.
     Applies to all members of union other than the Typed null (which should
     directly declare the type variation).
    """

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("timestamp"):
            warnings.warn(
                "ExpressionLiteral.timestamp is deprecated", DeprecationWarning
            )
        if self.is_set("timestamp_tz"):
            warnings.warn(
                "ExpressionLiteral.timestamp_tz is deprecated", DeprecationWarning
            )


@dataclass(eq=False, repr=False)
class ExpressionLiteralVarChar(betterproto.Message):
    value: str = betterproto.string_field(1)
    length: int = betterproto.uint32_field(2)


@dataclass(eq=False, repr=False)
class ExpressionLiteralDecimal(betterproto.Message):
    value: bytes = betterproto.bytes_field(1)
    """
    little-endian twos-complement integer representation of complete value
     (ignoring precision) Always 16 bytes in length
    """

    precision: int = betterproto.int32_field(2)
    """
    The maximum number of digits allowed in the value.
     the maximum precision is 38.
    """

    scale: int = betterproto.int32_field(3)
    """declared scale of decimal literal"""


@dataclass(eq=False, repr=False)
class ExpressionLiteralMap(betterproto.Message):
    key_values: List["ExpressionLiteralMapKeyValue"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ExpressionLiteralMapKeyValue(betterproto.Message):
    key: "ExpressionLiteral" = betterproto.message_field(1)
    value: "ExpressionLiteral" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ExpressionLiteralIntervalYearToMonth(betterproto.Message):
    years: int = betterproto.int32_field(1)
    months: int = betterproto.int32_field(2)


@dataclass(eq=False, repr=False)
class ExpressionLiteralIntervalDayToSecond(betterproto.Message):
    days: int = betterproto.int32_field(1)
    seconds: int = betterproto.int32_field(2)
    microseconds: int = betterproto.int32_field(3)


@dataclass(eq=False, repr=False)
class ExpressionLiteralStruct(betterproto.Message):
    fields: List["ExpressionLiteral"] = betterproto.message_field(1)
    """A possibly heterogeneously typed list of literals"""


@dataclass(eq=False, repr=False)
class ExpressionLiteralList(betterproto.Message):
    values: List["ExpressionLiteral"] = betterproto.message_field(1)
    """A homogeneously typed list of literals"""


@dataclass(eq=False, repr=False)
class ExpressionLiteralUserDefined(betterproto.Message):
    type_reference: int = betterproto.uint32_field(1)
    """points to a type_anchor defined in this plan"""

    type_parameters: List["TypeParameter"] = betterproto.message_field(3)
    """
    The parameters to be bound to the type class, if the type class is
     parameterizable.
    """

    value: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(
        2, group="val"
    )
    """
    the value of the literal, serialized using some type-specific protobuf message
    """

    struct: "ExpressionLiteralStruct" = betterproto.message_field(4, group="val")
    """
    the value of the literal, serialized using the structure definition in its declaration
    """


@dataclass(eq=False, repr=False)
class ExpressionNested(betterproto.Message):
    """Expression to dynamically construct nested types."""

    nullable: bool = betterproto.bool_field(1)
    """Whether the returned nested type is nullable."""

    type_variation_reference: int = betterproto.uint32_field(2)
    """
    Optionally points to a type_variation_anchor defined in this plan for
     the returned nested type.
    """

    struct: "ExpressionNestedStruct" = betterproto.message_field(3, group="nested_type")
    list: "ExpressionNestedList" = betterproto.message_field(4, group="nested_type")
    map: "ExpressionNestedMap" = betterproto.message_field(5, group="nested_type")


@dataclass(eq=False, repr=False)
class ExpressionNestedMap(betterproto.Message):
    key_values: List["ExpressionNestedMapKeyValue"] = betterproto.message_field(1)
    """
    One or more key-value pairs. To specify an empty map, use
     Literal.empty_map (otherwise type information would be missing).
    """


@dataclass(eq=False, repr=False)
class ExpressionNestedMapKeyValue(betterproto.Message):
    key: "Expression" = betterproto.message_field(1)
    """Mandatory key/value expressions."""

    value: "Expression" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ExpressionNestedStruct(betterproto.Message):
    fields: List["Expression"] = betterproto.message_field(1)
    """
    Zero or more possibly heterogeneously-typed list of expressions that
     form the struct fields.
    """


@dataclass(eq=False, repr=False)
class ExpressionNestedList(betterproto.Message):
    values: List["Expression"] = betterproto.message_field(1)
    """
    A homogeneously-typed list of one or more expressions that form the
     list entries. To specify an empty list, use Literal.empty_list
     (otherwise type information would be missing).
    """


@dataclass(eq=False, repr=False)
class ExpressionScalarFunction(betterproto.Message):
    """A scalar function call."""

    function_reference: int = betterproto.uint32_field(1)
    """
    Points to a function_anchor defined in this plan, which must refer
     to a scalar function in the associated YAML file. Required; avoid
     using anchor/reference zero.
    """

    arguments: List["FunctionArgument"] = betterproto.message_field(4)
    """
    The arguments to be bound to the function. This must have exactly the
     number of arguments specified in the function definition, and the
     argument types must also match exactly:
    
      - Value arguments must be bound using FunctionArgument.value, and
        the expression in that must yield a value of a type that a function
        overload is defined for.
      - Type arguments must be bound using FunctionArgument.type.
      - Enum arguments must be bound using FunctionArgument.enum
        followed by Enum.specified, with a string that case-insensitively
        matches one of the allowed options.
    """

    options: List["FunctionOption"] = betterproto.message_field(5)
    """
    Options to specify behavior for corner cases, or leave behavior
     unspecified if the consumer does not need specific behavior in these
     cases.
    """

    output_type: "Type" = betterproto.message_field(3)
    """
    Must be set to the return type of the function, exactly as derived
     using the declaration in the extension.
    """

    args: List["Expression"] = betterproto.message_field(2)
    """Deprecated; use arguments instead."""

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("args"):
            warnings.warn(
                "ExpressionScalarFunction.args is deprecated", DeprecationWarning
            )


@dataclass(eq=False, repr=False)
class ExpressionWindowFunction(betterproto.Message):
    """A window function call."""

    function_reference: int = betterproto.uint32_field(1)
    """
    Points to a function_anchor defined in this plan. The function must be:
      - a window function
      - an aggregate function
    
     An aggregate function referenced here should be treated as a window
     function with Window Type STREAMING
    
     Required; 0 is considered to be a valid anchor/reference.
    """

    arguments: List["FunctionArgument"] = betterproto.message_field(9)
    """
    The arguments to be bound to the function. This must have exactly the
     number of arguments specified in the function definition, and the
     argument types must also match exactly:
    
      - Value arguments must be bound using FunctionArgument.value, and
        the expression in that must yield a value of a type that a function
        overload is defined for.
      - Type arguments must be bound using FunctionArgument.type, and a
        function overload must be defined for that type.
      - Enum arguments must be bound using FunctionArgument.enum
        followed by Enum.specified, with a string that case-insensitively
        matches one of the allowed options.
    """

    options: List["FunctionOption"] = betterproto.message_field(11)
    """
    Options to specify behavior for corner cases, or leave behavior
     unspecified if the consumer does not need specific behavior in these
     cases.
    """

    output_type: "Type" = betterproto.message_field(7)
    """
    Must be set to the return type of the function, exactly as derived
     using the declaration in the extension.
    """

    phase: "AggregationPhase" = betterproto.enum_field(6)
    """
    Describes which part of the window function to perform within the
     context of distributed algorithms. Required. Must be set to
     INITIAL_TO_RESULT for window functions that are not decomposable.
    """

    sorts: List["SortField"] = betterproto.message_field(3)
    """
    If specified, the records that are part of the window defined by
     upper_bound and lower_bound are ordered according to this list
     before they are aggregated. The first sort field has the highest
     priority; only if a sort field determines two records to be equivalent
     is the next field queried. This field is optional, and is only allowed
     if the window function is defined to support sorting.
    """

    invocation: "AggregateFunctionAggregationInvocation" = betterproto.enum_field(10)
    """
    Specifies whether equivalent records are merged before being aggregated.
     Optional, defaults to AGGREGATION_INVOCATION_ALL.
    """

    partitions: List["Expression"] = betterproto.message_field(2)
    """
    When one or more partition expressions are specified, two records are
     considered to be in the same partition if and only if these expressions
     yield an equal record of values for both. When computing the window
     function, only the subset of records within the bounds that are also in
     the same partition as the current record are aggregated.
    """

    bounds_type: "ExpressionWindowFunctionBoundsType" = betterproto.enum_field(12)
    """Defines the bounds type: ROWS, RANGE"""

    lower_bound: "ExpressionWindowFunctionBound" = betterproto.message_field(5)
    """
    Defines the record relative to the current record from which the window
     extends. The bound is inclusive. If the lower bound indexes a record
     greater than the upper bound, TODO (null range/no records passed?
     wrapping around as if lower/upper were swapped? error? null?).
     Optional; defaults to the start of the partition.
    """

    upper_bound: "ExpressionWindowFunctionBound" = betterproto.message_field(4)
    """
    Defines the record relative to the current record up to which the window
     extends. The bound is inclusive. If the upper bound indexes a record
     less than the lower bound, TODO (null range/no records passed?
     wrapping around as if lower/upper were swapped? error? null?).
     Optional; defaults to the end of the partition.
    """

    args: List["Expression"] = betterproto.message_field(8)
    """Deprecated; use arguments instead."""

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("args"):
            warnings.warn(
                "ExpressionWindowFunction.args is deprecated", DeprecationWarning
            )


@dataclass(eq=False, repr=False)
class ExpressionWindowFunctionBound(betterproto.Message):
    """
    Defines one of the two boundaries for the window of a window function.
    """

    preceding: "ExpressionWindowFunctionBoundPreceding" = betterproto.message_field(
        1, group="kind"
    )
    """The bound extends some number of records behind the current record."""

    following: "ExpressionWindowFunctionBoundFollowing" = betterproto.message_field(
        2, group="kind"
    )
    """
    The bound extends some number of records ahead of the current
     record.
    """

    current_row: "ExpressionWindowFunctionBoundCurrentRow" = betterproto.message_field(
        3, group="kind"
    )
    """The bound extends to the current record."""

    unbounded: "ExpressionWindowFunctionBoundUnbounded" = betterproto.message_field(
        4, group="kind"
    )
    """
    The bound extends to the start of the partition or the end of the
     partition, depending on whether this represents the upper or lower
     bound.
    """


@dataclass(eq=False, repr=False)
class ExpressionWindowFunctionBoundPreceding(betterproto.Message):
    """
    Defines that the bound extends this far back from the current record.
    """

    offset: int = betterproto.int64_field(1)
    """
    A strictly positive integer specifying the number of records that
     the window extends back from the current record. Required. Use
     CurrentRow for offset zero and Following for negative offsets.
    """


@dataclass(eq=False, repr=False)
class ExpressionWindowFunctionBoundFollowing(betterproto.Message):
    """Defines that the bound extends this far ahead of the current record."""

    offset: int = betterproto.int64_field(1)
    """
    A strictly positive integer specifying the number of records that
     the window extends ahead of the current record. Required. Use
     CurrentRow for offset zero and Preceding for negative offsets.
    """


@dataclass(eq=False, repr=False)
class ExpressionWindowFunctionBoundCurrentRow(betterproto.Message):
    """Defines that the bound extends to or from the current record."""

    pass


@dataclass(eq=False, repr=False)
class ExpressionWindowFunctionBoundUnbounded(betterproto.Message):
    """
    Defines an "unbounded bound": for lower bounds this means the start
     of the partition, and for upper bounds this means the end of the
     partition.
    """

    pass


@dataclass(eq=False, repr=False)
class ExpressionIfThen(betterproto.Message):
    ifs: List["ExpressionIfThenIfClause"] = betterproto.message_field(1)
    """A list of one or more IfClauses"""

    else_: "Expression" = betterproto.message_field(2)
    """The returned Expression if no IfClauses are satisified"""


@dataclass(eq=False, repr=False)
class ExpressionIfThenIfClause(betterproto.Message):
    if_: "Expression" = betterproto.message_field(1)
    then: "Expression" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ExpressionCast(betterproto.Message):
    type: "Type" = betterproto.message_field(1)
    input: "Expression" = betterproto.message_field(2)
    failure_behavior: "ExpressionCastFailureBehavior" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class ExpressionSwitchExpression(betterproto.Message):
    match: "Expression" = betterproto.message_field(3)
    ifs: List["ExpressionSwitchExpressionIfValue"] = betterproto.message_field(1)
    else_: "Expression" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ExpressionSwitchExpressionIfValue(betterproto.Message):
    if_: "ExpressionLiteral" = betterproto.message_field(1)
    then: "Expression" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ExpressionSingularOrList(betterproto.Message):
    value: "Expression" = betterproto.message_field(1)
    options: List["Expression"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ExpressionMultiOrList(betterproto.Message):
    value: List["Expression"] = betterproto.message_field(1)
    options: List["ExpressionMultiOrListRecord"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ExpressionMultiOrListRecord(betterproto.Message):
    fields: List["Expression"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ExpressionEmbeddedFunction(betterproto.Message):
    arguments: List["Expression"] = betterproto.message_field(1)
    output_type: "Type" = betterproto.message_field(2)
    python_pickle_function: "ExpressionEmbeddedFunctionPythonPickleFunction" = (
        betterproto.message_field(3, group="kind")
    )
    web_assembly_function: "ExpressionEmbeddedFunctionWebAssemblyFunction" = (
        betterproto.message_field(4, group="kind")
    )


@dataclass(eq=False, repr=False)
class ExpressionEmbeddedFunctionPythonPickleFunction(betterproto.Message):
    function: bytes = betterproto.bytes_field(1)
    prerequisite: List[str] = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ExpressionEmbeddedFunctionWebAssemblyFunction(betterproto.Message):
    script: bytes = betterproto.bytes_field(1)
    prerequisite: List[str] = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ExpressionReferenceSegment(betterproto.Message):
    """
    A way to reference the inner property of a complex record. Can reference
     either a map key by literal, a struct field by the ordinal position of
     the desired field or a particular element in an array. Supports
     expressions that would roughly translate to something similar to:
     a.b[2].c['my_map_key'].x where a,b,c and x are struct field references
     (ordinalized in the internal representation here), [2] is a list offset
     and ['my_map_key'] is a reference into a map field.
    """

    map_key: "ExpressionReferenceSegmentMapKey" = betterproto.message_field(
        1, group="reference_type"
    )
    struct_field: "ExpressionReferenceSegmentStructField" = betterproto.message_field(
        2, group="reference_type"
    )
    list_element: "ExpressionReferenceSegmentListElement" = betterproto.message_field(
        3, group="reference_type"
    )


@dataclass(eq=False, repr=False)
class ExpressionReferenceSegmentMapKey(betterproto.Message):
    map_key: "ExpressionLiteral" = betterproto.message_field(1)
    """literal based reference to specific possible value in map."""

    child: "ExpressionReferenceSegment" = betterproto.message_field(2)
    """Optional child segment"""


@dataclass(eq=False, repr=False)
class ExpressionReferenceSegmentStructField(betterproto.Message):
    field: int = betterproto.int32_field(1)
    """zero-indexed ordinal position of field in struct"""

    child: "ExpressionReferenceSegment" = betterproto.message_field(2)
    """Optional child segment"""


@dataclass(eq=False, repr=False)
class ExpressionReferenceSegmentListElement(betterproto.Message):
    offset: int = betterproto.int32_field(1)
    """zero-indexed ordinal position of element in list"""

    child: "ExpressionReferenceSegment" = betterproto.message_field(2)
    """Optional child segment"""


@dataclass(eq=False, repr=False)
class ExpressionMaskExpression(betterproto.Message):
    """
    A reference that takes an existing subtype and selectively removes fields
     from it. For example, one might initially have an inner struct with 100
     fields but a a particular operation only needs to interact with only 2 of
     those 100 fields. In this situation, one would use a mask expression to
     eliminate the 98 fields that are not relevant to the rest of the operation
     pipeline.

     Note that this does not fundamentally alter the structure of data beyond
     the elimination of unnecessary elements.
    """

    select: "ExpressionMaskExpressionStructSelect" = betterproto.message_field(1)
    maintain_singular_struct: bool = betterproto.bool_field(2)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionSelect(betterproto.Message):
    struct: "ExpressionMaskExpressionStructSelect" = betterproto.message_field(
        1, group="type"
    )
    list: "ExpressionMaskExpressionListSelect" = betterproto.message_field(
        2, group="type"
    )
    map: "ExpressionMaskExpressionMapSelect" = betterproto.message_field(
        3, group="type"
    )


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionStructSelect(betterproto.Message):
    struct_items: List["ExpressionMaskExpressionStructItem"] = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionStructItem(betterproto.Message):
    field: int = betterproto.int32_field(1)
    child: "ExpressionMaskExpressionSelect" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionListSelect(betterproto.Message):
    selection: List["ExpressionMaskExpressionListSelectListSelectItem"] = (
        betterproto.message_field(1)
    )
    child: "ExpressionMaskExpressionSelect" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionListSelectListSelectItem(betterproto.Message):
    item: "ExpressionMaskExpressionListSelectListSelectItemListElement" = (
        betterproto.message_field(1, group="type")
    )
    slice: "ExpressionMaskExpressionListSelectListSelectItemListSlice" = (
        betterproto.message_field(2, group="type")
    )


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionListSelectListSelectItemListElement(betterproto.Message):
    field: int = betterproto.int32_field(1)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionListSelectListSelectItemListSlice(betterproto.Message):
    start: int = betterproto.int32_field(1)
    end: int = betterproto.int32_field(2)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionMapSelect(betterproto.Message):
    key: "ExpressionMaskExpressionMapSelectMapKey" = betterproto.message_field(
        1, group="select"
    )
    expression: "ExpressionMaskExpressionMapSelectMapKeyExpression" = (
        betterproto.message_field(2, group="select")
    )
    child: "ExpressionMaskExpressionSelect" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionMapSelectMapKey(betterproto.Message):
    map_key: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ExpressionMaskExpressionMapSelectMapKeyExpression(betterproto.Message):
    map_key_expression: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ExpressionFieldReference(betterproto.Message):
    """
    A reference to an inner part of a complex object. Can reference reference a
     single element or a masked version of elements
    """

    direct_reference: "ExpressionReferenceSegment" = betterproto.message_field(
        1, group="reference_type"
    )
    masked_reference: "ExpressionMaskExpression" = betterproto.message_field(
        2, group="reference_type"
    )
    expression: "Expression" = betterproto.message_field(3, group="root_type")
    root_reference: "ExpressionFieldReferenceRootReference" = betterproto.message_field(
        4, group="root_type"
    )
    outer_reference: "ExpressionFieldReferenceOuterReference" = (
        betterproto.message_field(5, group="root_type")
    )


@dataclass(eq=False, repr=False)
class ExpressionFieldReferenceRootReference(betterproto.Message):
    """
    Singleton that expresses this FieldReference is rooted off the root
     incoming record type
    """

    pass


@dataclass(eq=False, repr=False)
class ExpressionFieldReferenceOuterReference(betterproto.Message):
    """A root reference for the outer relation's subquery"""

    steps_out: int = betterproto.uint32_field(1)
    """
    number of subquery boundaries to traverse up for this field's reference
    
     This value must be >= 1
    """


@dataclass(eq=False, repr=False)
class ExpressionSubquery(betterproto.Message):
    """Subquery relation expression"""

    scalar: "ExpressionSubqueryScalar" = betterproto.message_field(
        1, group="subquery_type"
    )
    """Scalar subquery"""

    in_predicate: "ExpressionSubqueryInPredicate" = betterproto.message_field(
        2, group="subquery_type"
    )
    """x IN y predicate"""

    set_predicate: "ExpressionSubquerySetPredicate" = betterproto.message_field(
        3, group="subquery_type"
    )
    """EXISTS/UNIQUE predicate"""

    set_comparison: "ExpressionSubquerySetComparison" = betterproto.message_field(
        4, group="subquery_type"
    )
    """ANY/ALL predicate"""


@dataclass(eq=False, repr=False)
class ExpressionSubqueryScalar(betterproto.Message):
    """
    A subquery with one row and one column. This is often an aggregate
     though not required to be.
    """

    input: "Rel" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ExpressionSubqueryInPredicate(betterproto.Message):
    """
    Predicate checking that the left expression is contained in the right
     subquery

     Examples:

     x IN (SELECT * FROM t)
     (x, y) IN (SELECT a, b FROM t)
    """

    needles: List["Expression"] = betterproto.message_field(1)
    haystack: "Rel" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ExpressionSubquerySetPredicate(betterproto.Message):
    """
    A predicate over a set of rows in the form of a subquery
     EXISTS and UNIQUE are common SQL forms of this operation.
    """

    predicate_op: "ExpressionSubquerySetPredicatePredicateOp" = betterproto.enum_field(
        1
    )
    """TODO: should allow expressions"""

    tuples: "Rel" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ExpressionSubquerySetComparison(betterproto.Message):
    """
    A subquery comparison using ANY or ALL.
     Examples:

     SELECT *
     FROM t1
     WHERE x < ANY(SELECT y from t2)
    """

    reduction_op: "ExpressionSubquerySetComparisonReductionOp" = betterproto.enum_field(
        1
    )
    """ANY or ALL"""

    comparison_op: "ExpressionSubquerySetComparisonComparisonOp" = (
        betterproto.enum_field(2)
    )
    """A comparison operator"""

    left: "Expression" = betterproto.message_field(3)
    """left side of the expression"""

    right: "Rel" = betterproto.message_field(4)
    """right side of the expression"""


@dataclass(eq=False, repr=False)
class SortField(betterproto.Message):
    """
    The description of a field to sort on (including the direction of sorting and null semantics)
    """

    expr: "Expression" = betterproto.message_field(1)
    direction: "SortFieldSortDirection" = betterproto.enum_field(2, group="sort_kind")
    comparison_function_reference: int = betterproto.uint32_field(3, group="sort_kind")


@dataclass(eq=False, repr=False)
class AggregateFunction(betterproto.Message):
    """An aggregate function."""

    function_reference: int = betterproto.uint32_field(1)
    """
    Points to a function_anchor defined in this plan, which must refer
     to an aggregate function in the associated YAML file. Required; 0 is
     considered to be a valid anchor/reference.
    """

    arguments: List["FunctionArgument"] = betterproto.message_field(7)
    """
    The arguments to be bound to the function. This must have exactly the
     number of arguments specified in the function definition, and the
     argument types must also match exactly:
    
      - Value arguments must be bound using FunctionArgument.value, and
        the expression in that must yield a value of a type that a function
        overload is defined for.
      - Type arguments must be bound using FunctionArgument.type, and a
        function overload must be defined for that type.
      - Enum arguments must be bound using FunctionArgument.enum
        followed by Enum.specified, with a string that case-insensitively
        matches one of the allowed options.
      - Optional enum arguments must be bound using FunctionArgument.enum
        followed by either Enum.specified or Enum.unspecified. If specified,
        the string must case-insensitively match one of the allowed options.
    """

    options: List["FunctionOption"] = betterproto.message_field(8)
    """
    Options to specify behavior for corner cases, or leave behavior
     unspecified if the consumer does not need specific behavior in these
     cases.
    """

    output_type: "Type" = betterproto.message_field(5)
    """
    Must be set to the return type of the function, exactly as derived
     using the declaration in the extension.
    """

    phase: "AggregationPhase" = betterproto.enum_field(4)
    """
    Describes which part of the aggregation to perform within the context of
     distributed algorithms. Required. Must be set to INITIAL_TO_RESULT for
     aggregate functions that are not decomposable.
    """

    sorts: List["SortField"] = betterproto.message_field(3)
    """
    If specified, the aggregated records are ordered according to this list
     before they are aggregated. The first sort field has the highest
     priority; only if a sort field determines two records to be equivalent is
     the next field queried. This field is optional.
    """

    invocation: "AggregateFunctionAggregationInvocation" = betterproto.enum_field(6)
    """
    Specifies whether equivalent records are merged before being aggregated.
     Optional, defaults to AGGREGATION_INVOCATION_ALL.
    """

    args: List["Expression"] = betterproto.message_field(2)
    """deprecated; use arguments instead"""

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("args"):
            warnings.warn("AggregateFunction.args is deprecated", DeprecationWarning)


@dataclass(eq=False, repr=False)
class ReferenceRel(betterproto.Message):
    """
    This rel is used  to create references,
     in case we refer to a RelRoot field names will be ignored
    """

    subtree_ordinal: int = betterproto.int32_field(1)


@dataclass(eq=False, repr=False)
class PlanRel(betterproto.Message):
    """Either a relation or root relation"""

    rel: "Rel" = betterproto.message_field(1, group="rel_type")
    """Any relation (used for references and CTEs)"""

    root: "RelRoot" = betterproto.message_field(2, group="rel_type")
    """The root of a relation tree"""


@dataclass(eq=False, repr=False)
class Plan(betterproto.Message):
    """
    Describe a set of operations to complete.
     For compactness sake, identifiers are normalized at the plan level.
    """

    version: "Version" = betterproto.message_field(6)
    """
    Substrait version of the plan. Optional up to 0.17.0, required for later
     versions.
    """

    extension_uris: List["extensions.SimpleExtensionUri"] = betterproto.message_field(1)
    """a list of yaml specifications this plan may depend on"""

    extensions: List["extensions.SimpleExtensionDeclaration"] = (
        betterproto.message_field(2)
    )
    """a list of extensions this plan may depend on"""

    relations: List["PlanRel"] = betterproto.message_field(3)
    """one or more relation trees that are associated with this plan."""

    advanced_extensions: "extensions.AdvancedExtension" = betterproto.message_field(4)
    """additional extensions associated with this plan."""

    expected_type_urls: List[str] = betterproto.string_field(5)
    """
    A list of com.google.Any entities that this plan may use. Can be used to
     warn if some embedded message types are unknown. Note that this list may
     include message types that are ignorable (optimizations) or that are
     unused. In many cases, a consumer may be able to work with a plan even if
     one or more message types defined here are unknown.
    """


@dataclass(eq=False, repr=False)
class PlanVersion(betterproto.Message):
    """
    This message type can be used to deserialize only the version of a Substrait
     Plan message. This prevents deserialization errors when there were breaking
     changes between the Substrait version of the tool that produced the plan and
     the Substrait version used to deserialize it, such that a consumer can emit
     a more helpful error message in this case.
    """

    version: "Version" = betterproto.message_field(6)


@dataclass(eq=False, repr=False)
class Version(betterproto.Message):
    major_number: int = betterproto.uint32_field(1)
    """Substrait version number."""

    minor_number: int = betterproto.uint32_field(2)
    patch_number: int = betterproto.uint32_field(3)
    git_hash: str = betterproto.string_field(4)
    """
    If a particular version of Substrait is used that does not correspond to
     a version number exactly (for example when using an unofficial fork or
     using a version that is not yet released or is between versions), set this
     to the full git hash of the utilized commit of
     https://github.com/substrait-io/substrait (or fork thereof), represented
     using a lowercase hex ASCII string 40 characters in length. The version
     number above should be set to the most recent version tag in the history
     of that commit.
    """

    producer: str = betterproto.string_field(5)
    """
    Identifying information for the producer that created this plan. Under
     ideal circumstances, consumers should not need this information. However,
     it is foreseen that consumers may need to work around bugs in particular
     producers in practice, and therefore may need to know which producer
     created the plan.
    """


@dataclass(eq=False, repr=False)
class Capabilities(betterproto.Message):
    """
    Defines a set of Capabilities that a system (producer or consumer) supports.
    """

    substrait_versions: List[str] = betterproto.string_field(1)
    """List of Substrait versions this system supports"""

    advanced_extension_type_urls: List[str] = betterproto.string_field(2)
    """
    list of com.google.Any message types this system supports for advanced
     extensions.
    """

    simple_extensions: List["CapabilitiesSimpleExtension"] = betterproto.message_field(
        3
    )
    """list of simple extensions this system supports."""


@dataclass(eq=False, repr=False)
class CapabilitiesSimpleExtension(betterproto.Message):
    uri: str = betterproto.string_field(1)
    function_keys: List[str] = betterproto.string_field(2)
    type_keys: List[str] = betterproto.string_field(3)
    type_variation_keys: List[str] = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class ParameterizedType(betterproto.Message):
    bool: "TypeBoolean" = betterproto.message_field(1, group="kind")
    i8: "TypeI8" = betterproto.message_field(2, group="kind")
    i16: "TypeI16" = betterproto.message_field(3, group="kind")
    i32: "TypeI32" = betterproto.message_field(5, group="kind")
    i64: "TypeI64" = betterproto.message_field(7, group="kind")
    fp32: "TypeFp32" = betterproto.message_field(10, group="kind")
    fp64: "TypeFp64" = betterproto.message_field(11, group="kind")
    string: "TypeString" = betterproto.message_field(12, group="kind")
    binary: "TypeBinary" = betterproto.message_field(13, group="kind")
    timestamp: "TypeTimestamp" = betterproto.message_field(14, group="kind")
    """
    Deprecated in favor of `ParameterizedPrecisionTimestamp precision_timestamp`
    """

    date: "TypeDate" = betterproto.message_field(16, group="kind")
    time: "TypeTime" = betterproto.message_field(17, group="kind")
    interval_year: "TypeIntervalYear" = betterproto.message_field(19, group="kind")
    interval_day: "TypeIntervalDay" = betterproto.message_field(20, group="kind")
    timestamp_tz: "TypeTimestampTz" = betterproto.message_field(29, group="kind")
    """
    Deprecated in favor of `ParameterizedPrecisionTimestampTZ precision_timestamp_tz`
    """

    uuid: "TypeUuid" = betterproto.message_field(32, group="kind")
    fixed_char: "ParameterizedTypeParameterizedFixedChar" = betterproto.message_field(
        21, group="kind"
    )
    varchar: "ParameterizedTypeParameterizedVarChar" = betterproto.message_field(
        22, group="kind"
    )
    fixed_binary: "ParameterizedTypeParameterizedFixedBinary" = (
        betterproto.message_field(23, group="kind")
    )
    decimal: "ParameterizedTypeParameterizedDecimal" = betterproto.message_field(
        24, group="kind"
    )
    precision_timestamp: "ParameterizedTypeParameterizedPrecisionTimestamp" = (
        betterproto.message_field(34, group="kind")
    )
    precision_timestamp_tz: "ParameterizedTypeParameterizedPrecisionTimestampTz" = (
        betterproto.message_field(35, group="kind")
    )
    struct: "ParameterizedTypeParameterizedStruct" = betterproto.message_field(
        25, group="kind"
    )
    list: "ParameterizedTypeParameterizedList" = betterproto.message_field(
        27, group="kind"
    )
    map: "ParameterizedTypeParameterizedMap" = betterproto.message_field(
        28, group="kind"
    )
    user_defined: "ParameterizedTypeParameterizedUserDefined" = (
        betterproto.message_field(30, group="kind")
    )
    user_defined_pointer: int = betterproto.uint32_field(31, group="kind")
    """
    Deprecated in favor of user_defined, which allows nullability and
     variations to be specified. If user_defined_pointer is encountered,
     treat it as being non-nullable and having the default variation.
    """

    type_parameter: "ParameterizedTypeTypeParameter" = betterproto.message_field(
        33, group="kind"
    )

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("timestamp"):
            warnings.warn(
                "ParameterizedType.timestamp is deprecated", DeprecationWarning
            )
        if self.is_set("timestamp_tz"):
            warnings.warn(
                "ParameterizedType.timestamp_tz is deprecated", DeprecationWarning
            )
        if self.is_set("user_defined_pointer"):
            warnings.warn(
                "ParameterizedType.user_defined_pointer is deprecated",
                DeprecationWarning,
            )


@dataclass(eq=False, repr=False)
class ParameterizedTypeTypeParameter(betterproto.Message):
    name: str = betterproto.string_field(1)
    bounds: List["ParameterizedType"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ParameterizedTypeIntegerParameter(betterproto.Message):
    name: str = betterproto.string_field(1)
    range_start_inclusive: "ParameterizedTypeNullableInteger" = (
        betterproto.message_field(2)
    )
    range_end_exclusive: "ParameterizedTypeNullableInteger" = betterproto.message_field(
        3
    )


@dataclass(eq=False, repr=False)
class ParameterizedTypeNullableInteger(betterproto.Message):
    value: int = betterproto.int64_field(1)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedFixedChar(betterproto.Message):
    length: "ParameterizedTypeIntegerOption" = betterproto.message_field(1)
    variation_pointer: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedVarChar(betterproto.Message):
    length: "ParameterizedTypeIntegerOption" = betterproto.message_field(1)
    variation_pointer: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedFixedBinary(betterproto.Message):
    length: "ParameterizedTypeIntegerOption" = betterproto.message_field(1)
    variation_pointer: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedDecimal(betterproto.Message):
    scale: "ParameterizedTypeIntegerOption" = betterproto.message_field(1)
    precision: "ParameterizedTypeIntegerOption" = betterproto.message_field(2)
    variation_pointer: int = betterproto.uint32_field(3)
    nullability: "TypeNullability" = betterproto.enum_field(4)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedPrecisionTimestamp(betterproto.Message):
    precision: "ParameterizedTypeIntegerOption" = betterproto.message_field(1)
    variation_pointer: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedPrecisionTimestampTz(betterproto.Message):
    precision: "ParameterizedTypeIntegerOption" = betterproto.message_field(1)
    variation_pointer: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedStruct(betterproto.Message):
    types: List["ParameterizedType"] = betterproto.message_field(1)
    variation_pointer: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedNamedStruct(betterproto.Message):
    names: List[str] = betterproto.string_field(1)
    """list of names in dfs order"""

    struct: "ParameterizedTypeParameterizedStruct" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedList(betterproto.Message):
    type: "ParameterizedType" = betterproto.message_field(1)
    variation_pointer: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedMap(betterproto.Message):
    key: "ParameterizedType" = betterproto.message_field(1)
    value: "ParameterizedType" = betterproto.message_field(2)
    variation_pointer: int = betterproto.uint32_field(3)
    nullability: "TypeNullability" = betterproto.enum_field(4)


@dataclass(eq=False, repr=False)
class ParameterizedTypeParameterizedUserDefined(betterproto.Message):
    type_pointer: int = betterproto.uint32_field(1)
    variation_pointer: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class ParameterizedTypeIntegerOption(betterproto.Message):
    literal: int = betterproto.int32_field(1, group="integer_type")
    parameter: "ParameterizedTypeIntegerParameter" = betterproto.message_field(
        2, group="integer_type"
    )


@dataclass(eq=False, repr=False)
class DerivationExpression(betterproto.Message):
    bool: "TypeBoolean" = betterproto.message_field(1, group="kind")
    i8: "TypeI8" = betterproto.message_field(2, group="kind")
    i16: "TypeI16" = betterproto.message_field(3, group="kind")
    i32: "TypeI32" = betterproto.message_field(5, group="kind")
    i64: "TypeI64" = betterproto.message_field(7, group="kind")
    fp32: "TypeFp32" = betterproto.message_field(10, group="kind")
    fp64: "TypeFp64" = betterproto.message_field(11, group="kind")
    string: "TypeString" = betterproto.message_field(12, group="kind")
    binary: "TypeBinary" = betterproto.message_field(13, group="kind")
    timestamp: "TypeTimestamp" = betterproto.message_field(14, group="kind")
    """
    Deprecated in favor of `ExpressionPrecisionTimestamp precision_timestamp`
    """

    date: "TypeDate" = betterproto.message_field(16, group="kind")
    time: "TypeTime" = betterproto.message_field(17, group="kind")
    interval_year: "TypeIntervalYear" = betterproto.message_field(19, group="kind")
    interval_day: "TypeIntervalDay" = betterproto.message_field(20, group="kind")
    timestamp_tz: "TypeTimestampTz" = betterproto.message_field(29, group="kind")
    """
    Deprecated in favor of `ExpressionPrecisionTimestampTZ precision_timestamp_tz`
    """

    uuid: "TypeUuid" = betterproto.message_field(32, group="kind")
    fixed_char: "DerivationExpressionExpressionFixedChar" = betterproto.message_field(
        21, group="kind"
    )
    varchar: "DerivationExpressionExpressionVarChar" = betterproto.message_field(
        22, group="kind"
    )
    fixed_binary: "DerivationExpressionExpressionFixedBinary" = (
        betterproto.message_field(23, group="kind")
    )
    decimal: "DerivationExpressionExpressionDecimal" = betterproto.message_field(
        24, group="kind"
    )
    precision_timestamp: "DerivationExpressionExpressionPrecisionTimestamp" = (
        betterproto.message_field(40, group="kind")
    )
    precision_timestamp_tz: "DerivationExpressionExpressionPrecisionTimestampTz" = (
        betterproto.message_field(41, group="kind")
    )
    struct: "DerivationExpressionExpressionStruct" = betterproto.message_field(
        25, group="kind"
    )
    list: "DerivationExpressionExpressionList" = betterproto.message_field(
        27, group="kind"
    )
    map: "DerivationExpressionExpressionMap" = betterproto.message_field(
        28, group="kind"
    )
    user_defined: "DerivationExpressionExpressionUserDefined" = (
        betterproto.message_field(30, group="kind")
    )
    user_defined_pointer: int = betterproto.uint32_field(31, group="kind")
    """
    Deprecated in favor of user_defined, which allows nullability and
     variations to be specified. If user_defined_pointer is encountered,
     treat it as being non-nullable and having the default variation.
    """

    type_parameter_name: str = betterproto.string_field(33, group="kind")
    integer_parameter_name: str = betterproto.string_field(34, group="kind")
    integer_literal: int = betterproto.int32_field(35, group="kind")
    unary_op: "DerivationExpressionUnaryOp" = betterproto.message_field(
        36, group="kind"
    )
    binary_op: "DerivationExpressionBinaryOp" = betterproto.message_field(
        37, group="kind"
    )
    if_else: "DerivationExpressionIfElse" = betterproto.message_field(38, group="kind")
    return_program: "DerivationExpressionReturnProgram" = betterproto.message_field(
        39, group="kind"
    )

    def __post_init__(self) -> None:
        super().__post_init__()
        if self.is_set("timestamp"):
            warnings.warn(
                "DerivationExpression.timestamp is deprecated", DeprecationWarning
            )
        if self.is_set("timestamp_tz"):
            warnings.warn(
                "DerivationExpression.timestamp_tz is deprecated", DeprecationWarning
            )
        if self.is_set("user_defined_pointer"):
            warnings.warn(
                "DerivationExpression.user_defined_pointer is deprecated",
                DeprecationWarning,
            )


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionFixedChar(betterproto.Message):
    length: "DerivationExpression" = betterproto.message_field(1)
    variation_pointer: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionVarChar(betterproto.Message):
    length: "DerivationExpression" = betterproto.message_field(1)
    variation_pointer: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionFixedBinary(betterproto.Message):
    length: "DerivationExpression" = betterproto.message_field(1)
    variation_pointer: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionDecimal(betterproto.Message):
    scale: "DerivationExpression" = betterproto.message_field(1)
    precision: "DerivationExpression" = betterproto.message_field(2)
    variation_pointer: int = betterproto.uint32_field(3)
    nullability: "TypeNullability" = betterproto.enum_field(4)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionPrecisionTimestamp(betterproto.Message):
    precision: "DerivationExpression" = betterproto.message_field(1)
    variation_pointer: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionPrecisionTimestampTz(betterproto.Message):
    precision: "DerivationExpression" = betterproto.message_field(1)
    variation_pointer: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionStruct(betterproto.Message):
    types: List["DerivationExpression"] = betterproto.message_field(1)
    variation_pointer: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionNamedStruct(betterproto.Message):
    names: List[str] = betterproto.string_field(1)
    struct: "DerivationExpressionExpressionStruct" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionList(betterproto.Message):
    type: "DerivationExpression" = betterproto.message_field(1)
    variation_pointer: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionMap(betterproto.Message):
    key: "DerivationExpression" = betterproto.message_field(1)
    value: "DerivationExpression" = betterproto.message_field(2)
    variation_pointer: int = betterproto.uint32_field(3)
    nullability: "TypeNullability" = betterproto.enum_field(4)


@dataclass(eq=False, repr=False)
class DerivationExpressionExpressionUserDefined(betterproto.Message):
    type_pointer: int = betterproto.uint32_field(1)
    variation_pointer: int = betterproto.uint32_field(2)
    nullability: "TypeNullability" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class DerivationExpressionIfElse(betterproto.Message):
    if_condition: "DerivationExpression" = betterproto.message_field(1)
    if_return: "DerivationExpression" = betterproto.message_field(2)
    else_return: "DerivationExpression" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class DerivationExpressionUnaryOp(betterproto.Message):
    op_type: "DerivationExpressionUnaryOpUnaryOpType" = betterproto.enum_field(1)
    arg: "DerivationExpression" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class DerivationExpressionBinaryOp(betterproto.Message):
    op_type: "DerivationExpressionBinaryOpBinaryOpType" = betterproto.enum_field(1)
    arg1: "DerivationExpression" = betterproto.message_field(2)
    arg2: "DerivationExpression" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class DerivationExpressionReturnProgram(betterproto.Message):
    assignments: List["DerivationExpressionReturnProgramAssignment"] = (
        betterproto.message_field(1)
    )
    final_expression: "DerivationExpression" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class DerivationExpressionReturnProgramAssignment(betterproto.Message):
    name: str = betterproto.string_field(1)
    expression: "DerivationExpression" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class FunctionSignature(betterproto.Message):
    """List of function signatures available."""

    pass


@dataclass(eq=False, repr=False)
class FunctionSignatureFinalArgVariadic(betterproto.Message):
    min_args: int = betterproto.int64_field(1)
    """
    the minimum number of arguments allowed for the list of final arguments
     (inclusive).
    """

    max_args: int = betterproto.int64_field(2)
    """
    the maximum number of arguments allowed for the list of final arguments
     (exclusive)
    """

    consistency: "FunctionSignatureFinalArgVariadicParameterConsistency" = (
        betterproto.enum_field(3)
    )
    """the type of parameterized type consistency"""


@dataclass(eq=False, repr=False)
class FunctionSignatureFinalArgNormal(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class FunctionSignatureScalar(betterproto.Message):
    arguments: List["FunctionSignatureArgument"] = betterproto.message_field(2)
    name: List[str] = betterproto.string_field(3)
    description: "FunctionSignatureDescription" = betterproto.message_field(4)
    deterministic: bool = betterproto.bool_field(7)
    session_dependent: bool = betterproto.bool_field(8)
    output_type: "DerivationExpression" = betterproto.message_field(9)
    variadic: "FunctionSignatureFinalArgVariadic" = betterproto.message_field(
        10, group="final_variable_behavior"
    )
    normal: "FunctionSignatureFinalArgNormal" = betterproto.message_field(
        11, group="final_variable_behavior"
    )
    implementations: List["FunctionSignatureImplementation"] = (
        betterproto.message_field(12)
    )


@dataclass(eq=False, repr=False)
class FunctionSignatureAggregate(betterproto.Message):
    arguments: List["FunctionSignatureArgument"] = betterproto.message_field(2)
    name: str = betterproto.string_field(3)
    description: "FunctionSignatureDescription" = betterproto.message_field(4)
    deterministic: bool = betterproto.bool_field(7)
    session_dependent: bool = betterproto.bool_field(8)
    output_type: "DerivationExpression" = betterproto.message_field(9)
    variadic: "FunctionSignatureFinalArgVariadic" = betterproto.message_field(
        10, group="final_variable_behavior"
    )
    normal: "FunctionSignatureFinalArgNormal" = betterproto.message_field(
        11, group="final_variable_behavior"
    )
    ordered: bool = betterproto.bool_field(14)
    max_set: int = betterproto.uint64_field(12)
    intermediate_type: "Type" = betterproto.message_field(13)
    implementations: List["FunctionSignatureImplementation"] = (
        betterproto.message_field(15)
    )


@dataclass(eq=False, repr=False)
class FunctionSignatureWindow(betterproto.Message):
    arguments: List["FunctionSignatureArgument"] = betterproto.message_field(2)
    name: List[str] = betterproto.string_field(3)
    description: "FunctionSignatureDescription" = betterproto.message_field(4)
    deterministic: bool = betterproto.bool_field(7)
    session_dependent: bool = betterproto.bool_field(8)
    intermediate_type: "DerivationExpression" = betterproto.message_field(9)
    output_type: "DerivationExpression" = betterproto.message_field(10)
    variadic: "FunctionSignatureFinalArgVariadic" = betterproto.message_field(
        16, group="final_variable_behavior"
    )
    normal: "FunctionSignatureFinalArgNormal" = betterproto.message_field(
        17, group="final_variable_behavior"
    )
    ordered: bool = betterproto.bool_field(11)
    max_set: int = betterproto.uint64_field(12)
    window_type: "FunctionSignatureWindowWindowType" = betterproto.enum_field(14)
    implementations: List["FunctionSignatureImplementation"] = (
        betterproto.message_field(15)
    )


@dataclass(eq=False, repr=False)
class FunctionSignatureDescription(betterproto.Message):
    language: str = betterproto.string_field(1)
    body: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class FunctionSignatureImplementation(betterproto.Message):
    type: "FunctionSignatureImplementationType" = betterproto.enum_field(1)
    uri: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class FunctionSignatureArgument(betterproto.Message):
    name: str = betterproto.string_field(1)
    value: "FunctionSignatureArgumentValueArgument" = betterproto.message_field(
        2, group="argument_kind"
    )
    type: "FunctionSignatureArgumentTypeArgument" = betterproto.message_field(
        3, group="argument_kind"
    )
    enum: "FunctionSignatureArgumentEnumArgument" = betterproto.message_field(
        4, group="argument_kind"
    )


@dataclass(eq=False, repr=False)
class FunctionSignatureArgumentValueArgument(betterproto.Message):
    type: "ParameterizedType" = betterproto.message_field(1)
    constant: bool = betterproto.bool_field(2)


@dataclass(eq=False, repr=False)
class FunctionSignatureArgumentTypeArgument(betterproto.Message):
    type: "ParameterizedType" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class FunctionSignatureArgumentEnumArgument(betterproto.Message):
    options: List[str] = betterproto.string_field(1)
    optional: bool = betterproto.bool_field(2)


@dataclass(eq=False, repr=False)
class ExpressionReference(betterproto.Message):
    expression: "Expression" = betterproto.message_field(1, group="expr_type")
    measure: "AggregateFunction" = betterproto.message_field(2, group="expr_type")
    output_names: List[str] = betterproto.string_field(3)
    """Field names in depth-first order"""


@dataclass(eq=False, repr=False)
class ExtendedExpression(betterproto.Message):
    """
    Describe a set of operations to complete.
     For compactness sake, identifiers are normalized at the plan level.
    """

    version: "Version" = betterproto.message_field(7)
    """
    Substrait version of the expression. Optional up to 0.17.0, required for later
     versions.
    """

    extension_uris: List["extensions.SimpleExtensionUri"] = betterproto.message_field(1)
    """a list of yaml specifications this expression may depend on"""

    extensions: List["extensions.SimpleExtensionDeclaration"] = (
        betterproto.message_field(2)
    )
    """a list of extensions this expression may depend on"""

    referred_expr: List["ExpressionReference"] = betterproto.message_field(3)
    """one or more expression trees with same order in plan rel"""

    base_schema: "NamedStruct" = betterproto.message_field(4)
    advanced_extensions: "extensions.AdvancedExtension" = betterproto.message_field(5)
    """additional extensions associated with this expression."""

    expected_type_urls: List[str] = betterproto.string_field(6)
    """
    A list of com.google.Any entities that this plan may use. Can be used to
     warn if some embedded message types are unknown. Note that this list may
     include message types that are ignorable (optimizations) or that are
     unused. In many cases, a consumer may be able to work with a plan even if
     one or more message types defined here are unknown.
    """
